const char* prefix = "/*********************************************************************\n"
"* Filename:   aes.h\n"
"* Author:     Brad Conte (brad AT bradconte.com)\n"
"* Copyright:\n"
"* Disclaimer: This code is presented \"as is\" without any guarantees.\n"
"* Details:    Defines the API for the corresponding AES implementation.\n"
"*********************************************************************/\n"
"\n"
"#include <string.h>\n"
"#include <stdlib.h>\n"
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <linux/perf_event.h>\n"
"#include <linux/hw_breakpoint.h>\n"
"#include <sys/ioctl.h>\n"
"#include <asm/unistd.h>\n"
"#ifndef AES_H\n"
"#define AES_H\n"
"\n"
"/*************************** HEADER FILES ***************************/\n"
"#include <stddef.h>\n"
"\n"
"/****************************** MACROS ******************************/\n"
"#define AES_BLOCK_SIZE 16               // AES operates on 16 bytes at a time\n"
"\n"
"/**************************** DATA TYPES ****************************/\n"
"typedef unsigned char BYTE;            // 8-bit byte\n"
"typedef unsigned int WORD;             // 32-bit word, change to \"long\" for 16-bit machines\n"
"\n"
"/*********************** FUNCTION DECLARATIONS **********************/\n"
"///////////////////\n"
"// AES\n"
"///////////////////\n"
"// Key setup must be done before any AES en/de-cryption functions can be used.\n"
"void aes_key_setup(const BYTE key[],          // The key, must be 128, 192, or 256 bits\n"
"                   WORD w[],                  // Output key schedule to be used later\n"
"                   int keysize);              // Bit length of the key, 128, 192, or 256\n"
"\n"
"void aes_encrypt(const BYTE in[],             // 16 bytes of plaintext\n"
"                 BYTE out[],                  // 16 bytes of ciphertext\n"
"                 const WORD key[],            // From the key setup\n"
"                 int keysize);                // Bit length of the key, 128, 192, or 256\n"
"\n"
"void aes_decrypt(const BYTE in[],             // 16 bytes of ciphertext\n"
"                 BYTE out[],                  // 16 bytes of plaintext\n"
"                 const WORD key[],            // From the key setup\n"
"                 int keysize);                // Bit length of the key, 128, 192, or 256\n"
"\n"
"///////////////////\n"
"// AES - CBC\n"
"///////////////////\n"
"int aes_encrypt_cbc(const BYTE in[],          // Plaintext\n"
"                    size_t in_len,            // Must be a multiple of AES_BLOCK_SIZE\n"
"                    BYTE out[],               // Ciphertext, same length as plaintext\n"
"                    const WORD key[],         // From the key setup\n"
"                    int keysize,              // Bit length of the key, 128, 192, or 256\n"
"                    const BYTE iv[]);         // IV, must be AES_BLOCK_SIZE bytes long\n"
"\n"
"// Only output the CBC-MAC of the input.\n"
"int aes_encrypt_cbc_mac(const BYTE in[],      // plaintext\n"
"                        size_t in_len,        // Must be a multiple of AES_BLOCK_SIZE\n"
"                        BYTE out[],           // Output MAC\n"
"                        const WORD key[],     // From the key setup\n"
"                        int keysize,          // Bit length of the key, 128, 192, or 256\n"
"                        const BYTE iv[]);     // IV, must be AES_BLOCK_SIZE bytes long\n"
"\n"
"///////////////////\n"
"// AES - CTR\n"
"///////////////////\n"
"void increment_iv(BYTE iv[],                  // Must be a multiple of AES_BLOCK_SIZE\n"
"                  int counter_size);          // Bytes of the IV used for counting (low end)\n"
"\n"
"void aes_encrypt_ctr(const BYTE in[],         // Plaintext\n"
"                     size_t in_len,           // Any byte length\n"
"                     BYTE out[],              // Ciphertext, same length as plaintext\n"
"                     const WORD key[],        // From the key setup\n"
"                     int keysize,             // Bit length of the key, 128, 192, or 256\n"
"                     const BYTE iv[]);        // IV, must be AES_BLOCK_SIZE bytes long\n"
"\n"
"void aes_decrypt_ctr(const BYTE in[],         // Ciphertext\n"
"                     size_t in_len,           // Any byte length\n"
"                     BYTE out[],              // Plaintext, same length as ciphertext\n"
"                     const WORD key[],        // From the key setup\n"
"                     int keysize,             // Bit length of the key, 128, 192, or 256\n"
"                     const BYTE iv[]);        // IV, must be AES_BLOCK_SIZE bytes long\n"
"\n"
"///////////////////\n"
"// AES - CCM\n"
"///////////////////\n"
"// Returns True if the input parameters do not violate any constraint.\n"
"int aes_encrypt_ccm(const BYTE plaintext[],              // IN  - Plaintext.\n"
"                    WORD plaintext_len,                  // IN  - Plaintext length.\n"
"                    const BYTE associated_data[],        // IN  - Associated Data included in authentication, but not encryption.\n"
"                    unsigned short associated_data_len,  // IN  - Associated Data length in bytes.\n"
"                    const BYTE nonce[],                  // IN  - The Nonce to be used for encryption.\n"
"                    unsigned short nonce_len,            // IN  - Nonce length in bytes.\n"
"                    BYTE ciphertext[],                   // OUT - Ciphertext, a concatination of the plaintext and the MAC.\n"
"                    WORD *ciphertext_len,                // OUT - The length of the ciphertext, always plaintext_len + mac_len.\n"
"                    WORD mac_len,                        // IN  - The desired length of the MAC, must be 4, 6, 8, 10, 12, 14, or 16.\n"
"                    const BYTE key[],                    // IN  - The AES key for encryption.\n"
"                    int keysize);                        // IN  - The length of the key in bits. Valid values are 128, 192, 256.\n"
"\n"
"// Returns True if the input parameters do not violate any constraint.\n"
"// Use mac_auth to ensure decryption/validation was preformed correctly.\n"
"// If authentication does not succeed, the plaintext is zeroed out. To overwride\n"
"// this, call with mac_auth = NULL. The proper proceedure is to decrypt with\n"
"// authentication enabled (mac_auth != NULL) and make a second call to that\n"
"// ignores authentication explicitly if the first call failes.\n"
"int aes_decrypt_ccm(const BYTE ciphertext[],             // IN  - Ciphertext, the concatination of encrypted plaintext and MAC.\n"
"                    WORD ciphertext_len,                 // IN  - Ciphertext length in bytes.\n"
"                    const BYTE assoc[],                  // IN  - The Associated Data, required for authentication.\n"
"                    unsigned short assoc_len,            // IN  - Associated Data length in bytes.\n"
"                    const BYTE nonce[],                  // IN  - The Nonce to use for decryption, same one as for encryption.\n"
"                    unsigned short nonce_len,            // IN  - Nonce length in bytes.\n"
"                    BYTE plaintext[],                    // OUT - The plaintext that was decrypted. Will need to be large enough to hold ciphertext_len - mac_len.\n"
"                    WORD *plaintext_len,                 // OUT - Length in bytes of the output plaintext, always ciphertext_len - mac_len .\n"
"                    WORD mac_len,                        // IN  - The length of the MAC that was calculated.\n"
"                    int *mac_auth,                       // OUT - TRUE if authentication succeeded, FALSE if it did not. NULL pointer will ignore the authentication.\n"
"                    const BYTE key[],                    // IN  - The AES key for decryption.\n"
"                    int keysize);                        // IN  - The length of the key in BITS. Valid values are 128, 192, 256.\n"
"\n"
"///////////////////\n"
"// Test functions\n"
"///////////////////\n"
"int aes_test();\n"
"int aes_ecb_test();\n"
"int aes_cbc_test();\n"
"int aes_ctr_test();\n"
"int aes_ccm_test();\n"
"\n"
"#endif   // AES_H\n"
"\n"
"\n"
"/*********************************************************************\n"
"* Filename:   aes.c\n"
"* Author:     Brad Conte (brad AT bradconte.com)\n"
"* Copyright:\n"
"* Disclaimer: This code is presented \"as is\" without any guarantees.\n"
"* Details:    This code is the implementation of the AES algorithm and\n"
"              the CTR, CBC, and CCM modes of operation it can be used in.\n"
"               AES is, specified by the NIST in in publication FIPS PUB 197,\n"
"              availible at:\n"
"               * http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf .\n"
"              The CBC and CTR modes of operation are specified by\n"
"              NIST SP 800-38 A, available at:\n"
"               * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf .\n"
"              The CCM mode of operation is specified by NIST SP80-38 C, available at:\n"
"               * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf\n"
"*********************************************************************/\n"
"\n"
"/*************************** HEADER FILES ***************************/\n"
"\n"
"#include <stdio.h>\n"
"\n"
"/****************************** MACROS ******************************/\n"
"// The least significant byte of the word is rotated to the end.\n"
"#define KE_ROTWORD(x) (((x) << 8) | ((x) >> 24))\n"
"\n"
"#define TRUE  1\n"
"#define FALSE 0\n"
"\n"
"/**************************** DATA TYPES ****************************/\n"
"#define AES_128_ROUNDS 10\n"
"#define AES_192_ROUNDS 12\n"
"#define AES_256_ROUNDS 14\n"
"\n"
"/*********************** FUNCTION DECLARATIONS **********************/\n"
"void ccm_prepare_first_ctr_blk(BYTE counter[], const BYTE nonce[], int nonce_len, int payload_len_store_size);\n"
"void ccm_prepare_first_format_blk(BYTE buf[], int assoc_len, int payload_len, int payload_len_store_size, int mac_len, const BYTE nonce[], int nonce_len);\n"
"void ccm_format_assoc_data(BYTE buf[], int *end_of_buf, const BYTE assoc[], int assoc_len);\n"
"void ccm_format_payload_data(BYTE buf[], int *end_of_buf, const BYTE payload[], int payload_len);\n"
"\n"
"/**************************** VARIABLES *****************************/\n"
"// This is the specified AES SBox. To look up a substitution value, put the first\n"
"// nibble in the first index (row) and the second nibble in the second index (column).\n"
"static const BYTE aes_sbox[16][16] = {\n"
"	{0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76},\n"
"	{0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0},\n"
"	{0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15},\n"
"	{0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75},\n"
"	{0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84},\n"
"	{0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF},\n"
"	{0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8},\n"
"	{0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2},\n"
"	{0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73},\n"
"	{0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB},\n"
"	{0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79},\n"
"	{0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08},\n"
"	{0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A},\n"
"	{0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E},\n"
"	{0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF},\n"
"	{0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16}\n"
"};\n"
"\n"
"static const BYTE aes_invsbox[16][16] = {\n"
"	{0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB},\n"
"	{0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB},\n"
"	{0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E},\n"
"	{0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25},\n"
"	{0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92},\n"
"	{0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84},\n"
"	{0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06},\n"
"	{0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B},\n"
"	{0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73},\n"
"	{0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E},\n"
"	{0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B},\n"
"	{0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4},\n"
"	{0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F},\n"
"	{0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF},\n"
"	{0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61},\n"
"	{0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D}\n"
"};\n"
"\n"
"// This table stores pre-calculated values for all possible GF(2^8) calculations.This\n"
"// table is only used by the (Inv)MixColumns steps.\n"
"// USAGE: The second index (column) is the coefficient of multiplication. Only 7 different\n"
"// coefficients are used: 0x01, 0x02, 0x03, 0x09, 0x0b, 0x0d, 0x0e, but multiplication by\n"
"// 1 is negligible leaving only 6 coefficients. Each column of the table is devoted to one\n"
"// of these coefficients, in the ascending order of value, from values 0x00 to 0xFF.\n"
"static const BYTE gf_mul[256][6] = {\n"
"	{0x00,0x00,0x00,0x00,0x00,0x00},{0x02,0x03,0x09,0x0b,0x0d,0x0e},\n"
"	{0x04,0x06,0x12,0x16,0x1a,0x1c},{0x06,0x05,0x1b,0x1d,0x17,0x12},\n"
"	{0x08,0x0c,0x24,0x2c,0x34,0x38},{0x0a,0x0f,0x2d,0x27,0x39,0x36},\n"
"	{0x0c,0x0a,0x36,0x3a,0x2e,0x24},{0x0e,0x09,0x3f,0x31,0x23,0x2a},\n"
"	{0x10,0x18,0x48,0x58,0x68,0x70},{0x12,0x1b,0x41,0x53,0x65,0x7e},\n"
"	{0x14,0x1e,0x5a,0x4e,0x72,0x6c},{0x16,0x1d,0x53,0x45,0x7f,0x62},\n"
"	{0x18,0x14,0x6c,0x74,0x5c,0x48},{0x1a,0x17,0x65,0x7f,0x51,0x46},\n"
"	{0x1c,0x12,0x7e,0x62,0x46,0x54},{0x1e,0x11,0x77,0x69,0x4b,0x5a},\n"
"	{0x20,0x30,0x90,0xb0,0xd0,0xe0},{0x22,0x33,0x99,0xbb,0xdd,0xee},\n"
"	{0x24,0x36,0x82,0xa6,0xca,0xfc},{0x26,0x35,0x8b,0xad,0xc7,0xf2},\n"
"	{0x28,0x3c,0xb4,0x9c,0xe4,0xd8},{0x2a,0x3f,0xbd,0x97,0xe9,0xd6},\n"
"	{0x2c,0x3a,0xa6,0x8a,0xfe,0xc4},{0x2e,0x39,0xaf,0x81,0xf3,0xca},\n"
"	{0x30,0x28,0xd8,0xe8,0xb8,0x90},{0x32,0x2b,0xd1,0xe3,0xb5,0x9e},\n"
"	{0x34,0x2e,0xca,0xfe,0xa2,0x8c},{0x36,0x2d,0xc3,0xf5,0xaf,0x82},\n"
"	{0x38,0x24,0xfc,0xc4,0x8c,0xa8},{0x3a,0x27,0xf5,0xcf,0x81,0xa6},\n"
"	{0x3c,0x22,0xee,0xd2,0x96,0xb4},{0x3e,0x21,0xe7,0xd9,0x9b,0xba},\n"
"	{0x40,0x60,0x3b,0x7b,0xbb,0xdb},{0x42,0x63,0x32,0x70,0xb6,0xd5},\n"
"	{0x44,0x66,0x29,0x6d,0xa1,0xc7},{0x46,0x65,0x20,0x66,0xac,0xc9},\n"
"	{0x48,0x6c,0x1f,0x57,0x8f,0xe3},{0x4a,0x6f,0x16,0x5c,0x82,0xed},\n"
"	{0x4c,0x6a,0x0d,0x41,0x95,0xff},{0x4e,0x69,0x04,0x4a,0x98,0xf1},\n"
"	{0x50,0x78,0x73,0x23,0xd3,0xab},{0x52,0x7b,0x7a,0x28,0xde,0xa5},\n"
"	{0x54,0x7e,0x61,0x35,0xc9,0xb7},{0x56,0x7d,0x68,0x3e,0xc4,0xb9},\n"
"	{0x58,0x74,0x57,0x0f,0xe7,0x93},{0x5a,0x77,0x5e,0x04,0xea,0x9d},\n"
"	{0x5c,0x72,0x45,0x19,0xfd,0x8f},{0x5e,0x71,0x4c,0x12,0xf0,0x81},\n"
"	{0x60,0x50,0xab,0xcb,0x6b,0x3b},{0x62,0x53,0xa2,0xc0,0x66,0x35},\n"
"	{0x64,0x56,0xb9,0xdd,0x71,0x27},{0x66,0x55,0xb0,0xd6,0x7c,0x29},\n"
"	{0x68,0x5c,0x8f,0xe7,0x5f,0x03},{0x6a,0x5f,0x86,0xec,0x52,0x0d},\n"
"	{0x6c,0x5a,0x9d,0xf1,0x45,0x1f},{0x6e,0x59,0x94,0xfa,0x48,0x11},\n"
"	{0x70,0x48,0xe3,0x93,0x03,0x4b},{0x72,0x4b,0xea,0x98,0x0e,0x45},\n"
"	{0x74,0x4e,0xf1,0x85,0x19,0x57},{0x76,0x4d,0xf8,0x8e,0x14,0x59},\n"
"	{0x78,0x44,0xc7,0xbf,0x37,0x73},{0x7a,0x47,0xce,0xb4,0x3a,0x7d},\n"
"	{0x7c,0x42,0xd5,0xa9,0x2d,0x6f},{0x7e,0x41,0xdc,0xa2,0x20,0x61},\n"
"	{0x80,0xc0,0x76,0xf6,0x6d,0xad},{0x82,0xc3,0x7f,0xfd,0x60,0xa3},\n"
"	{0x84,0xc6,0x64,0xe0,0x77,0xb1},{0x86,0xc5,0x6d,0xeb,0x7a,0xbf},\n"
"	{0x88,0xcc,0x52,0xda,0x59,0x95},{0x8a,0xcf,0x5b,0xd1,0x54,0x9b},\n"
"	{0x8c,0xca,0x40,0xcc,0x43,0x89},{0x8e,0xc9,0x49,0xc7,0x4e,0x87},\n"
"	{0x90,0xd8,0x3e,0xae,0x05,0xdd},{0x92,0xdb,0x37,0xa5,0x08,0xd3},\n"
"	{0x94,0xde,0x2c,0xb8,0x1f,0xc1},{0x96,0xdd,0x25,0xb3,0x12,0xcf},\n"
"	{0x98,0xd4,0x1a,0x82,0x31,0xe5},{0x9a,0xd7,0x13,0x89,0x3c,0xeb},\n"
"	{0x9c,0xd2,0x08,0x94,0x2b,0xf9},{0x9e,0xd1,0x01,0x9f,0x26,0xf7},\n"
"	{0xa0,0xf0,0xe6,0x46,0xbd,0x4d},{0xa2,0xf3,0xef,0x4d,0xb0,0x43},\n"
"	{0xa4,0xf6,0xf4,0x50,0xa7,0x51},{0xa6,0xf5,0xfd,0x5b,0xaa,0x5f},\n"
"	{0xa8,0xfc,0xc2,0x6a,0x89,0x75},{0xaa,0xff,0xcb,0x61,0x84,0x7b},\n"
"	{0xac,0xfa,0xd0,0x7c,0x93,0x69},{0xae,0xf9,0xd9,0x77,0x9e,0x67},\n"
"	{0xb0,0xe8,0xae,0x1e,0xd5,0x3d},{0xb2,0xeb,0xa7,0x15,0xd8,0x33},\n"
"	{0xb4,0xee,0xbc,0x08,0xcf,0x21},{0xb6,0xed,0xb5,0x03,0xc2,0x2f},\n"
"	{0xb8,0xe4,0x8a,0x32,0xe1,0x05},{0xba,0xe7,0x83,0x39,0xec,0x0b},\n"
"	{0xbc,0xe2,0x98,0x24,0xfb,0x19},{0xbe,0xe1,0x91,0x2f,0xf6,0x17},\n"
"	{0xc0,0xa0,0x4d,0x8d,0xd6,0x76},{0xc2,0xa3,0x44,0x86,0xdb,0x78},\n"
"	{0xc4,0xa6,0x5f,0x9b,0xcc,0x6a},{0xc6,0xa5,0x56,0x90,0xc1,0x64},\n"
"	{0xc8,0xac,0x69,0xa1,0xe2,0x4e},{0xca,0xaf,0x60,0xaa,0xef,0x40},\n"
"	{0xcc,0xaa,0x7b,0xb7,0xf8,0x52},{0xce,0xa9,0x72,0xbc,0xf5,0x5c},\n"
"	{0xd0,0xb8,0x05,0xd5,0xbe,0x06},{0xd2,0xbb,0x0c,0xde,0xb3,0x08},\n"
"	{0xd4,0xbe,0x17,0xc3,0xa4,0x1a},{0xd6,0xbd,0x1e,0xc8,0xa9,0x14},\n"
"	{0xd8,0xb4,0x21,0xf9,0x8a,0x3e},{0xda,0xb7,0x28,0xf2,0x87,0x30},\n"
"	{0xdc,0xb2,0x33,0xef,0x90,0x22},{0xde,0xb1,0x3a,0xe4,0x9d,0x2c},\n"
"	{0xe0,0x90,0xdd,0x3d,0x06,0x96},{0xe2,0x93,0xd4,0x36,0x0b,0x98},\n"
"	{0xe4,0x96,0xcf,0x2b,0x1c,0x8a},{0xe6,0x95,0xc6,0x20,0x11,0x84},\n"
"	{0xe8,0x9c,0xf9,0x11,0x32,0xae},{0xea,0x9f,0xf0,0x1a,0x3f,0xa0},\n"
"	{0xec,0x9a,0xeb,0x07,0x28,0xb2},{0xee,0x99,0xe2,0x0c,0x25,0xbc},\n"
"	{0xf0,0x88,0x95,0x65,0x6e,0xe6},{0xf2,0x8b,0x9c,0x6e,0x63,0xe8},\n"
"	{0xf4,0x8e,0x87,0x73,0x74,0xfa},{0xf6,0x8d,0x8e,0x78,0x79,0xf4},\n"
"	{0xf8,0x84,0xb1,0x49,0x5a,0xde},{0xfa,0x87,0xb8,0x42,0x57,0xd0},\n"
"	{0xfc,0x82,0xa3,0x5f,0x40,0xc2},{0xfe,0x81,0xaa,0x54,0x4d,0xcc},\n"
"	{0x1b,0x9b,0xec,0xf7,0xda,0x41},{0x19,0x98,0xe5,0xfc,0xd7,0x4f},\n"
"	{0x1f,0x9d,0xfe,0xe1,0xc0,0x5d},{0x1d,0x9e,0xf7,0xea,0xcd,0x53},\n"
"	{0x13,0x97,0xc8,0xdb,0xee,0x79},{0x11,0x94,0xc1,0xd0,0xe3,0x77},\n"
"	{0x17,0x91,0xda,0xcd,0xf4,0x65},{0x15,0x92,0xd3,0xc6,0xf9,0x6b},\n"
"	{0x0b,0x83,0xa4,0xaf,0xb2,0x31},{0x09,0x80,0xad,0xa4,0xbf,0x3f},\n"
"	{0x0f,0x85,0xb6,0xb9,0xa8,0x2d},{0x0d,0x86,0xbf,0xb2,0xa5,0x23},\n"
"	{0x03,0x8f,0x80,0x83,0x86,0x09},{0x01,0x8c,0x89,0x88,0x8b,0x07},\n"
"	{0x07,0x89,0x92,0x95,0x9c,0x15},{0x05,0x8a,0x9b,0x9e,0x91,0x1b},\n"
"	{0x3b,0xab,0x7c,0x47,0x0a,0xa1},{0x39,0xa8,0x75,0x4c,0x07,0xaf},\n"
"	{0x3f,0xad,0x6e,0x51,0x10,0xbd},{0x3d,0xae,0x67,0x5a,0x1d,0xb3},\n"
"	{0x33,0xa7,0x58,0x6b,0x3e,0x99},{0x31,0xa4,0x51,0x60,0x33,0x97},\n"
"	{0x37,0xa1,0x4a,0x7d,0x24,0x85},{0x35,0xa2,0x43,0x76,0x29,0x8b},\n"
"	{0x2b,0xb3,0x34,0x1f,0x62,0xd1},{0x29,0xb0,0x3d,0x14,0x6f,0xdf},\n"
"	{0x2f,0xb5,0x26,0x09,0x78,0xcd},{0x2d,0xb6,0x2f,0x02,0x75,0xc3},\n"
"	{0x23,0xbf,0x10,0x33,0x56,0xe9},{0x21,0xbc,0x19,0x38,0x5b,0xe7},\n"
"	{0x27,0xb9,0x02,0x25,0x4c,0xf5},{0x25,0xba,0x0b,0x2e,0x41,0xfb},\n"
"	{0x5b,0xfb,0xd7,0x8c,0x61,0x9a},{0x59,0xf8,0xde,0x87,0x6c,0x94},\n"
"	{0x5f,0xfd,0xc5,0x9a,0x7b,0x86},{0x5d,0xfe,0xcc,0x91,0x76,0x88},\n"
"	{0x53,0xf7,0xf3,0xa0,0x55,0xa2},{0x51,0xf4,0xfa,0xab,0x58,0xac},\n"
"	{0x57,0xf1,0xe1,0xb6,0x4f,0xbe},{0x55,0xf2,0xe8,0xbd,0x42,0xb0},\n"
"	{0x4b,0xe3,0x9f,0xd4,0x09,0xea},{0x49,0xe0,0x96,0xdf,0x04,0xe4},\n"
"	{0x4f,0xe5,0x8d,0xc2,0x13,0xf6},{0x4d,0xe6,0x84,0xc9,0x1e,0xf8},\n"
"	{0x43,0xef,0xbb,0xf8,0x3d,0xd2},{0x41,0xec,0xb2,0xf3,0x30,0xdc},\n"
"	{0x47,0xe9,0xa9,0xee,0x27,0xce},{0x45,0xea,0xa0,0xe5,0x2a,0xc0},\n"
"	{0x7b,0xcb,0x47,0x3c,0xb1,0x7a},{0x79,0xc8,0x4e,0x37,0xbc,0x74},\n"
"	{0x7f,0xcd,0x55,0x2a,0xab,0x66},{0x7d,0xce,0x5c,0x21,0xa6,0x68},\n"
"	{0x73,0xc7,0x63,0x10,0x85,0x42},{0x71,0xc4,0x6a,0x1b,0x88,0x4c},\n"
"	{0x77,0xc1,0x71,0x06,0x9f,0x5e},{0x75,0xc2,0x78,0x0d,0x92,0x50},\n"
"	{0x6b,0xd3,0x0f,0x64,0xd9,0x0a},{0x69,0xd0,0x06,0x6f,0xd4,0x04},\n"
"	{0x6f,0xd5,0x1d,0x72,0xc3,0x16},{0x6d,0xd6,0x14,0x79,0xce,0x18},\n"
"	{0x63,0xdf,0x2b,0x48,0xed,0x32},{0x61,0xdc,0x22,0x43,0xe0,0x3c},\n"
"	{0x67,0xd9,0x39,0x5e,0xf7,0x2e},{0x65,0xda,0x30,0x55,0xfa,0x20},\n"
"	{0x9b,0x5b,0x9a,0x01,0xb7,0xec},{0x99,0x58,0x93,0x0a,0xba,0xe2},\n"
"	{0x9f,0x5d,0x88,0x17,0xad,0xf0},{0x9d,0x5e,0x81,0x1c,0xa0,0xfe},\n"
"	{0x93,0x57,0xbe,0x2d,0x83,0xd4},{0x91,0x54,0xb7,0x26,0x8e,0xda},\n"
"	{0x97,0x51,0xac,0x3b,0x99,0xc8},{0x95,0x52,0xa5,0x30,0x94,0xc6},\n"
"	{0x8b,0x43,0xd2,0x59,0xdf,0x9c},{0x89,0x40,0xdb,0x52,0xd2,0x92},\n"
"	{0x8f,0x45,0xc0,0x4f,0xc5,0x80},{0x8d,0x46,0xc9,0x44,0xc8,0x8e},\n"
"	{0x83,0x4f,0xf6,0x75,0xeb,0xa4},{0x81,0x4c,0xff,0x7e,0xe6,0xaa},\n"
"	{0x87,0x49,0xe4,0x63,0xf1,0xb8},{0x85,0x4a,0xed,0x68,0xfc,0xb6},\n"
"	{0xbb,0x6b,0x0a,0xb1,0x67,0x0c},{0xb9,0x68,0x03,0xba,0x6a,0x02},\n"
"	{0xbf,0x6d,0x18,0xa7,0x7d,0x10},{0xbd,0x6e,0x11,0xac,0x70,0x1e},\n"
"	{0xb3,0x67,0x2e,0x9d,0x53,0x34},{0xb1,0x64,0x27,0x96,0x5e,0x3a},\n"
"	{0xb7,0x61,0x3c,0x8b,0x49,0x28},{0xb5,0x62,0x35,0x80,0x44,0x26},\n"
"	{0xab,0x73,0x42,0xe9,0x0f,0x7c},{0xa9,0x70,0x4b,0xe2,0x02,0x72},\n"
"	{0xaf,0x75,0x50,0xff,0x15,0x60},{0xad,0x76,0x59,0xf4,0x18,0x6e},\n"
"	{0xa3,0x7f,0x66,0xc5,0x3b,0x44},{0xa1,0x7c,0x6f,0xce,0x36,0x4a},\n"
"	{0xa7,0x79,0x74,0xd3,0x21,0x58},{0xa5,0x7a,0x7d,0xd8,0x2c,0x56},\n"
"	{0xdb,0x3b,0xa1,0x7a,0x0c,0x37},{0xd9,0x38,0xa8,0x71,0x01,0x39},\n"
"	{0xdf,0x3d,0xb3,0x6c,0x16,0x2b},{0xdd,0x3e,0xba,0x67,0x1b,0x25},\n"
"	{0xd3,0x37,0x85,0x56,0x38,0x0f},{0xd1,0x34,0x8c,0x5d,0x35,0x01},\n"
"	{0xd7,0x31,0x97,0x40,0x22,0x13},{0xd5,0x32,0x9e,0x4b,0x2f,0x1d},\n"
"	{0xcb,0x23,0xe9,0x22,0x64,0x47},{0xc9,0x20,0xe0,0x29,0x69,0x49},\n"
"	{0xcf,0x25,0xfb,0x34,0x7e,0x5b},{0xcd,0x26,0xf2,0x3f,0x73,0x55},\n"
"	{0xc3,0x2f,0xcd,0x0e,0x50,0x7f},{0xc1,0x2c,0xc4,0x05,0x5d,0x71},\n"
"	{0xc7,0x29,0xdf,0x18,0x4a,0x63},{0xc5,0x2a,0xd6,0x13,0x47,0x6d},\n"
"	{0xfb,0x0b,0x31,0xca,0xdc,0xd7},{0xf9,0x08,0x38,0xc1,0xd1,0xd9},\n"
"	{0xff,0x0d,0x23,0xdc,0xc6,0xcb},{0xfd,0x0e,0x2a,0xd7,0xcb,0xc5},\n"
"	{0xf3,0x07,0x15,0xe6,0xe8,0xef},{0xf1,0x04,0x1c,0xed,0xe5,0xe1},\n"
"	{0xf7,0x01,0x07,0xf0,0xf2,0xf3},{0xf5,0x02,0x0e,0xfb,0xff,0xfd},\n"
"	{0xeb,0x13,0x79,0x92,0xb4,0xa7},{0xe9,0x10,0x70,0x99,0xb9,0xa9},\n"
"	{0xef,0x15,0x6b,0x84,0xae,0xbb},{0xed,0x16,0x62,0x8f,0xa3,0xb5},\n"
"	{0xe3,0x1f,0x5d,0xbe,0x80,0x9f},{0xe1,0x1c,0x54,0xb5,0x8d,0x91},\n"
"	{0xe7,0x19,0x4f,0xa8,0x9a,0x83},{0xe5,0x1a,0x46,0xa3,0x97,0x8d}\n"
"};\n"
"\n"
"/*********************** FUNCTION DEFINITIONS ***********************/\n"
"// XORs the in and out buffers, storing the result in out. Length is in bytes.\n"
"void xor_buf(const BYTE in[], BYTE out[], size_t len)\n"
"{\n"
"	size_t idx;\n"
"\n"
"	for (idx = 0; idx < len; idx++)\n"
"		out[idx] ^= in[idx];\n"
"}\n"
"\n"
"/*******************\n"
"* AES - CBC\n"
"*******************/\n"
"int aes_encrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n"
"{\n"
"	BYTE buf_in[AES_BLOCK_SIZE], buf_out[AES_BLOCK_SIZE], iv_buf[AES_BLOCK_SIZE];\n"
"	int blocks, idx;\n"
"\n"
"	if (in_len % AES_BLOCK_SIZE != 0)\n"
"		return(FALSE);\n"
"\n"
"	blocks = in_len / AES_BLOCK_SIZE;\n"
"\n"
"	memcpy(iv_buf, iv, AES_BLOCK_SIZE);\n"
"\n"
"	for (idx = 0; idx < blocks; idx++) {\n"
"		memcpy(buf_in, &in[idx * AES_BLOCK_SIZE], AES_BLOCK_SIZE);\n"
"		xor_buf(iv_buf, buf_in, AES_BLOCK_SIZE);\n"
"		aes_encrypt(buf_in, buf_out, key, keysize);\n"
"		memcpy(&out[idx * AES_BLOCK_SIZE], buf_out, AES_BLOCK_SIZE);\n"
"		memcpy(iv_buf, buf_out, AES_BLOCK_SIZE);\n"
"	}\n"
"\n"
"	return(TRUE);\n"
"}\n"
"\n"
"int aes_encrypt_cbc_mac(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n"
"{\n"
"	BYTE buf_in[AES_BLOCK_SIZE], buf_out[AES_BLOCK_SIZE], iv_buf[AES_BLOCK_SIZE];\n"
"	int blocks, idx;\n"
"\n"
"	if (in_len % AES_BLOCK_SIZE != 0)\n"
"		return(FALSE);\n"
"\n"
"	blocks = in_len / AES_BLOCK_SIZE;\n"
"\n"
"	memcpy(iv_buf, iv, AES_BLOCK_SIZE);\n"
"\n"
"	for (idx = 0; idx < blocks; idx++) {\n"
"		memcpy(buf_in, &in[idx * AES_BLOCK_SIZE], AES_BLOCK_SIZE);\n"
"		xor_buf(iv_buf, buf_in, AES_BLOCK_SIZE);\n"
"		aes_encrypt(buf_in, buf_out, key, keysize);\n"
"		memcpy(iv_buf, buf_out, AES_BLOCK_SIZE);\n"
"		// Do not output all encrypted blocks.\n"
"	}\n"
"\n"
"	memcpy(out, buf_out, AES_BLOCK_SIZE);   // Only output the last block.\n"
"\n"
"	return(TRUE);\n"
"}\n"
"\n"
"int aes_decrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n"
"{\n"
"	BYTE buf_in[AES_BLOCK_SIZE], buf_out[AES_BLOCK_SIZE], iv_buf[AES_BLOCK_SIZE];\n"
"	int blocks, idx;\n"
"\n"
"	if (in_len % AES_BLOCK_SIZE != 0)\n"
"		return(FALSE);\n"
"\n"
"	blocks = in_len / AES_BLOCK_SIZE;\n"
"\n"
"	memcpy(iv_buf, iv, AES_BLOCK_SIZE);\n"
"\n"
"	for (idx = 0; idx < blocks; idx++) {\n"
"		memcpy(buf_in, &in[idx * AES_BLOCK_SIZE], AES_BLOCK_SIZE);\n"
"		aes_decrypt(buf_in, buf_out, key, keysize);\n"
"		xor_buf(iv_buf, buf_out, AES_BLOCK_SIZE);\n"
"		memcpy(&out[idx * AES_BLOCK_SIZE], buf_out, AES_BLOCK_SIZE);\n"
"		memcpy(iv_buf, buf_in, AES_BLOCK_SIZE);\n"
"	}\n"
"\n"
"	return(TRUE);\n"
"}\n"
"\n"
"/*******************\n"
"* AES - CTR\n"
"*******************/\n"
"void increment_iv(BYTE iv[], int counter_size)\n"
"{\n"
"	int idx;\n"
"\n"
"	// Use counter_size bytes at the end of the IV as the big-endian integer to increment.\n"
"	for (idx = AES_BLOCK_SIZE - 1; idx >= AES_BLOCK_SIZE - counter_size; idx--) {\n"
"		iv[idx]++;\n"
"		if (iv[idx] != 0 || idx == AES_BLOCK_SIZE - counter_size)\n"
"			break;\n"
"	}\n"
"}\n"
"\n"
"// Performs the encryption in-place, the input and output buffers may be the same.\n"
"// Input may be an arbitrary length (in bytes).\n"
"void aes_encrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n"
"{\n"
"	size_t idx = 0, last_block_length;\n"
"	BYTE iv_buf[AES_BLOCK_SIZE], out_buf[AES_BLOCK_SIZE];\n"
"\n"
"	if (in != out)\n"
"		memcpy(out, in, in_len);\n"
"\n"
"	memcpy(iv_buf, iv, AES_BLOCK_SIZE);\n"
"	last_block_length = in_len - AES_BLOCK_SIZE;\n"
"\n"
"	if (in_len > AES_BLOCK_SIZE) {\n"
"		for (idx = 0; idx < last_block_length; idx += AES_BLOCK_SIZE) {\n"
"			aes_encrypt(iv_buf, out_buf, key, keysize);\n"
"			xor_buf(out_buf, &out[idx], AES_BLOCK_SIZE);\n"
"			increment_iv(iv_buf, AES_BLOCK_SIZE);\n"
"		}\n"
"	}\n"
"\n"
"	aes_encrypt(iv_buf, out_buf, key, keysize);\n"
"	xor_buf(out_buf, &out[idx], in_len - idx);   // Use the Most Significant bytes.\n"
"}\n"
"\n"
"void aes_decrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n"
"{\n"
"	// CTR encryption is its own inverse function.\n"
"	aes_encrypt_ctr(in, in_len, out, key, keysize, iv);\n"
"}\n"
"\n"
"/*******************\n"
"* AES - CCM\n"
"*******************/\n"
"// out_len = payload_len + assoc_len\n"
"int aes_encrypt_ccm(const BYTE payload[], WORD payload_len, const BYTE assoc[], unsigned short assoc_len,\n"
"                    const BYTE nonce[], unsigned short nonce_len, BYTE out[], WORD *out_len,\n"
"                    WORD mac_len, const BYTE key_str[], int keysize)\n"
"{\n"
"	BYTE temp_iv[AES_BLOCK_SIZE], counter[AES_BLOCK_SIZE], mac[16], *buf;\n"
"	int end_of_buf, payload_len_store_size;\n"
"	WORD key[60];\n"
"\n"
"	if (mac_len != 4 && mac_len != 6 && mac_len != 8 && mac_len != 10 &&\n"
"	   mac_len != 12 && mac_len != 14 && mac_len != 16)\n"
"		return(FALSE);\n"
"\n"
"	if (nonce_len < 7 || nonce_len > 13)\n"
"		return(FALSE);\n"
"\n"
"	if (assoc_len > 32768 /* = 2^15 */)\n"
"		return(FALSE);\n"
"\n"
"	buf = (BYTE*)malloc(payload_len + assoc_len + 48 /*Round both payload and associated data up a block size and add an extra block.*/);\n"
"	if (! buf)\n"
"		return(FALSE);\n"
"\n"
"	// Prepare the key for usage.\n"
"	aes_key_setup(key_str, key, keysize);\n"
"\n"
"	// Format the first block of the formatted data.\n"
"	payload_len_store_size = AES_BLOCK_SIZE - 1 - nonce_len;\n"
"	ccm_prepare_first_format_blk(buf, assoc_len, payload_len, payload_len_store_size, mac_len, nonce, nonce_len);\n"
"	end_of_buf = AES_BLOCK_SIZE;\n"
"\n"
"	// Format the Associated Data, aka, assoc[].\n"
"	ccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len);\n"
"\n"
"	// Format the Payload, aka payload[].\n"
"	ccm_format_payload_data(buf, &end_of_buf, payload, payload_len);\n"
"\n"
"	// Create the first counter block.\n"
"	ccm_prepare_first_ctr_blk(counter, nonce, nonce_len, payload_len_store_size);\n"
"\n"
"	// Perform the CBC operation with an IV of zeros on the formatted buffer to calculate the MAC.\n"
"	memset(temp_iv, 0, AES_BLOCK_SIZE);\n"
"	aes_encrypt_cbc_mac(buf, end_of_buf, mac, key, keysize, temp_iv);\n"
"\n"
"	// Copy the Payload and MAC to the output buffer.\n"
"	memcpy(out, payload, payload_len);\n"
"	memcpy(&out[payload_len], mac, mac_len);\n"
"\n"
"	// Encrypt the Payload with CTR mode with a counter starting at 1.\n"
"	memcpy(temp_iv, counter, AES_BLOCK_SIZE);\n"
"	increment_iv(temp_iv, AES_BLOCK_SIZE - 1 - mac_len);   // Last argument is the byte size of the counting portion of the counter block. /*BUG?*/\n"
"	aes_encrypt_ctr(out, payload_len, out, key, keysize, temp_iv);\n"
"\n"
"	// Encrypt the MAC with CTR mode with a counter starting at 0.\n"
"	aes_encrypt_ctr(&out[payload_len], mac_len, &out[payload_len], key, keysize, counter);\n"
"\n"
"	free(buf);\n"
"	*out_len = payload_len + mac_len;\n"
"\n"
"	return(TRUE);\n"
"}\n"
"\n"
"// plaintext_len = ciphertext_len - mac_len\n"
"// Needs a flag for whether the MAC matches.\n"
"int aes_decrypt_ccm(const BYTE ciphertext[], WORD ciphertext_len, const BYTE assoc[], unsigned short assoc_len,\n"
"                    const BYTE nonce[], unsigned short nonce_len, BYTE plaintext[], WORD *plaintext_len,\n"
"                    WORD mac_len, int *mac_auth, const BYTE key_str[], int keysize)\n"
"{\n"
"	BYTE temp_iv[AES_BLOCK_SIZE], counter[AES_BLOCK_SIZE], mac[16], mac_buf[16], *buf;\n"
"	int end_of_buf, plaintext_len_store_size;\n"
"	WORD key[60];\n"
"\n"
"	if (ciphertext_len <= mac_len)\n"
"		return(FALSE);\n"
"\n"
"	buf = (BYTE*)malloc(assoc_len + ciphertext_len /*ciphertext_len = plaintext_len + mac_len*/ + 48);\n"
"	if (! buf)\n"
"		return(FALSE);\n"
"\n"
"	// Prepare the key for usage.\n"
"	aes_key_setup(key_str, key, keysize);\n"
"\n"
"	// Copy the plaintext and MAC to the output buffers.\n"
"	*plaintext_len = ciphertext_len - mac_len;\n"
"	plaintext_len_store_size = AES_BLOCK_SIZE - 1 - nonce_len;\n"
"	memcpy(plaintext, ciphertext, *plaintext_len);\n"
"	memcpy(mac, &ciphertext[*plaintext_len], mac_len);\n"
"\n"
"	// Prepare the first counter block for use in decryption.\n"
"	ccm_prepare_first_ctr_blk(counter, nonce, nonce_len, plaintext_len_store_size);\n"
"\n"
"	// Decrypt the Payload with CTR mode with a counter starting at 1.\n"
"	memcpy(temp_iv, counter, AES_BLOCK_SIZE);\n"
"	increment_iv(temp_iv, AES_BLOCK_SIZE - 1 - mac_len);   // (AES_BLOCK_SIZE - 1 - mac_len) is the byte size of the counting portion of the counter block.\n"
"	aes_decrypt_ctr(plaintext, *plaintext_len, plaintext, key, keysize, temp_iv);\n"
"\n"
"	// Setting mac_auth to NULL disables the authentication check.\n"
"	if (mac_auth != NULL) {\n"
"		// Decrypt the MAC with CTR mode with a counter starting at 0.\n"
"		aes_decrypt_ctr(mac, mac_len, mac, key, keysize, counter);\n"
"\n"
"		// Format the first block of the formatted data.\n"
"		plaintext_len_store_size = AES_BLOCK_SIZE - 1 - nonce_len;\n"
"		ccm_prepare_first_format_blk(buf, assoc_len, *plaintext_len, plaintext_len_store_size, mac_len, nonce, nonce_len);\n"
"		end_of_buf = AES_BLOCK_SIZE;\n"
"\n"
"		// Format the Associated Data into the authentication buffer.\n"
"		ccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len);\n"
"\n"
"		// Format the Payload into the authentication buffer.\n"
"		ccm_format_payload_data(buf, &end_of_buf, plaintext, *plaintext_len);\n"
"\n"
"		// Perform the CBC operation with an IV of zeros on the formatted buffer to calculate the MAC.\n"
"		memset(temp_iv, 0, AES_BLOCK_SIZE);\n"
"		aes_encrypt_cbc_mac(buf, end_of_buf, mac_buf, key, keysize, temp_iv);\n"
"\n"
"		// Compare the calculated MAC against the MAC embedded in the ciphertext to see if they are the same.\n"
"		if (! memcmp(mac, mac_buf, mac_len)) {\n"
"			*mac_auth = TRUE;\n"
"		}\n"
"		else {\n"
"			*mac_auth = FALSE;\n"
"			memset(plaintext, 0, *plaintext_len);\n"
"		}\n"
"	}\n"
"\n"
"	free(buf);\n"
"\n"
"	return(TRUE);\n"
"}\n"
"\n"
"// Creates the first counter block. First byte is flags, then the nonce, then the incremented part.\n"
"void ccm_prepare_first_ctr_blk(BYTE counter[], const BYTE nonce[], int nonce_len, int payload_len_store_size)\n"
"{\n"
"	memset(counter, 0, AES_BLOCK_SIZE);\n"
"	counter[0] = (payload_len_store_size - 1) & 0x07;\n"
"	memcpy(&counter[1], nonce, nonce_len);\n"
"}\n"
"\n"
"void ccm_prepare_first_format_blk(BYTE buf[], int assoc_len, int payload_len, int payload_len_store_size, int mac_len, const BYTE nonce[], int nonce_len)\n"
"{\n"
"	// Set the flags for the first byte of the first block.\n"
"	buf[0] = ((((mac_len - 2) / 2) & 0x07) << 3) | ((payload_len_store_size - 1) & 0x07);\n"
"	if (assoc_len > 0)\n"
"		buf[0] += 0x40;\n"
"	// Format the rest of the first block, storing the nonce and the size of the payload.\n"
"	memcpy(&buf[1], nonce, nonce_len);\n"
"	memset(&buf[1 + nonce_len], 0, AES_BLOCK_SIZE - 1 - nonce_len);\n"
"	buf[15] = payload_len & 0x000000FF;\n"
"	buf[14] = (payload_len >> 8) & 0x000000FF;\n"
"}\n"
"\n"
"void ccm_format_assoc_data(BYTE buf[], int *end_of_buf, const BYTE assoc[], int assoc_len)\n"
"{\n"
"	int pad;\n"
"\n"
"	buf[*end_of_buf + 1] = assoc_len & 0x00FF;\n"
"	buf[*end_of_buf] = (assoc_len >> 8) & 0x00FF;\n"
"	*end_of_buf += 2;\n"
"	memcpy(&buf[*end_of_buf], assoc, assoc_len);\n"
"	*end_of_buf += assoc_len;\n"
"	pad = AES_BLOCK_SIZE - (*end_of_buf % AES_BLOCK_SIZE); /*BUG?*/\n"
"	memset(&buf[*end_of_buf], 0, pad);\n"
"	*end_of_buf += pad;\n"
"}\n"
"\n"
"void ccm_format_payload_data(BYTE buf[], int *end_of_buf, const BYTE payload[], int payload_len)\n"
"{\n"
"	int pad;\n"
"\n"
"	memcpy(&buf[*end_of_buf], payload, payload_len);\n"
"	*end_of_buf += payload_len;\n"
"	pad = *end_of_buf % AES_BLOCK_SIZE;\n"
"	if (pad != 0)\n"
"		pad = AES_BLOCK_SIZE - pad;\n"
"	memset(&buf[*end_of_buf], 0, pad);\n"
"	*end_of_buf += pad;\n"
"}\n"
"\n"
"/*******************\n"
"* AES\n"
"*******************/\n"
"/////////////////\n"
"// KEY EXPANSION\n"
"/////////////////\n"
"\n"
"// Substitutes a word using the AES S-Box.\n"
"WORD SubWord(WORD word)\n"
"{\n"
"	unsigned int result;\n"
"\n"
"	result = (int)aes_sbox[(word >> 4) & 0x0000000F][word & 0x0000000F];\n"
"	result += (int)aes_sbox[(word >> 12) & 0x0000000F][(word >> 8) & 0x0000000F] << 8;\n"
"	result += (int)aes_sbox[(word >> 20) & 0x0000000F][(word >> 16) & 0x0000000F] << 16;\n"
"	result += (int)aes_sbox[(word >> 28) & 0x0000000F][(word >> 24) & 0x0000000F] << 24;\n"
"	return(result);\n"
"}\n"
"\n"
"// Performs the action of generating the keys that will be used in every round of\n"
"// encryption. \"key\" is the user-supplied input key, \"w\" is the output key schedule,\n"
"// \"keysize\" is the length in bits of \"key\", must be 128, 192, or 256.\n"
"void aes_key_setup(const BYTE key[], WORD w[], int keysize)\n"
"{\n"
"	int Nb=4,Nr,Nk,idx;\n"
"	WORD temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,\n"
"	                  0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000,\n"
"	                  0xab000000,0x4d000000,0x9a000000};\n"
"\n"
"	switch (keysize) {\n"
"		case 128: Nr = 10; Nk = 4; break;\n"
"		case 192: Nr = 12; Nk = 6; break;\n"
"		case 256: Nr = 14; Nk = 8; break;\n"
"		default: return;\n"
"	}\n"
"\n"
"	for (idx=0; idx < Nk; ++idx) {\n"
"		w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) |\n"
"				   ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3]));\n"
"	}\n"
"\n"
"	for (idx = Nk; idx < Nb * (Nr+1); ++idx) {\n"
"		temp = w[idx - 1];\n"
"		if ((idx % Nk) == 0)\n"
"			temp = SubWord(KE_ROTWORD(temp)) ^ Rcon[(idx-1)/Nk];\n"
"		else if (Nk > 6 && (idx % Nk) == 4)\n"
"			temp = SubWord(temp);\n"
"		w[idx] = w[idx-Nk] ^ temp;\n"
"	}\n"
"}\n"
"\n"
"/////////////////\n"
"// ADD ROUND KEY\n"
"/////////////////\n"
"\n"
"// Performs the AddRoundKey step. Each round has its own pre-generated 16-byte key in the\n"
"// form of 4 integers (the \"w\" array). Each integer is XOR'd by one column of the state.\n"
"// Also performs the job of InvAddRoundKey(); since the function is a simple XOR process,\n"
"// it is its own inverse.\n"
"void AddRoundKey(BYTE state[][4], const WORD w[])\n"
"{\n"
"	BYTE subkey[4];\n"
"\n"
"	// memcpy(subkey,&w[idx],4); // Not accurate for big endian machines\n"
"	// Subkey 1\n"
"	subkey[0] = w[0] >> 24;\n"
"	subkey[1] = w[0] >> 16;\n"
"	subkey[2] = w[0] >> 8;\n"
"	subkey[3] = w[0];\n"
"	state[0][0] ^= subkey[0];\n"
"	state[1][0] ^= subkey[1];\n"
"	state[2][0] ^= subkey[2];\n"
"	state[3][0] ^= subkey[3];\n"
"	// Subkey 2\n"
"	subkey[0] = w[1] >> 24;\n"
"	subkey[1] = w[1] >> 16;\n"
"	subkey[2] = w[1] >> 8;\n"
"	subkey[3] = w[1];\n"
"	state[0][1] ^= subkey[0];\n"
"	state[1][1] ^= subkey[1];\n"
"	state[2][1] ^= subkey[2];\n"
"	state[3][1] ^= subkey[3];\n"
"	// Subkey 3\n"
"	subkey[0] = w[2] >> 24;\n"
"	subkey[1] = w[2] >> 16;\n"
"	subkey[2] = w[2] >> 8;\n"
"	subkey[3] = w[2];\n"
"	state[0][2] ^= subkey[0];\n"
"	state[1][2] ^= subkey[1];\n"
"	state[2][2] ^= subkey[2];\n"
"	state[3][2] ^= subkey[3];\n"
"	// Subkey 4\n"
"	subkey[0] = w[3] >> 24;\n"
"	subkey[1] = w[3] >> 16;\n"
"	subkey[2] = w[3] >> 8;\n"
"	subkey[3] = w[3];\n"
"	state[0][3] ^= subkey[0];\n"
"	state[1][3] ^= subkey[1];\n"
"	state[2][3] ^= subkey[2];\n"
"	state[3][3] ^= subkey[3];\n"
"}\n"
"\n"
"/////////////////\n"
"// (Inv)SubBytes\n"
"/////////////////\n"
"\n"
"// Performs the SubBytes step. All bytes in the state are substituted with a\n"
"// pre-calculated value from a lookup table.\n"
"void SubBytes(BYTE state[][4])\n"
"{\n"
"	state[0][0] = aes_sbox[state[0][0] >> 4][state[0][0] & 0x0F];\n"
"	state[0][1] = aes_sbox[state[0][1] >> 4][state[0][1] & 0x0F];\n"
"	state[0][2] = aes_sbox[state[0][2] >> 4][state[0][2] & 0x0F];\n"
"	state[0][3] = aes_sbox[state[0][3] >> 4][state[0][3] & 0x0F];\n"
"	state[1][0] = aes_sbox[state[1][0] >> 4][state[1][0] & 0x0F];\n"
"	state[1][1] = aes_sbox[state[1][1] >> 4][state[1][1] & 0x0F];\n"
"	state[1][2] = aes_sbox[state[1][2] >> 4][state[1][2] & 0x0F];\n"
"	state[1][3] = aes_sbox[state[1][3] >> 4][state[1][3] & 0x0F];\n"
"	state[2][0] = aes_sbox[state[2][0] >> 4][state[2][0] & 0x0F];\n"
"	state[2][1] = aes_sbox[state[2][1] >> 4][state[2][1] & 0x0F];\n"
"	state[2][2] = aes_sbox[state[2][2] >> 4][state[2][2] & 0x0F];\n"
"	state[2][3] = aes_sbox[state[2][3] >> 4][state[2][3] & 0x0F];\n"
"	state[3][0] = aes_sbox[state[3][0] >> 4][state[3][0] & 0x0F];\n"
"	state[3][1] = aes_sbox[state[3][1] >> 4][state[3][1] & 0x0F];\n"
"	state[3][2] = aes_sbox[state[3][2] >> 4][state[3][2] & 0x0F];\n"
"	state[3][3] = aes_sbox[state[3][3] >> 4][state[3][3] & 0x0F];\n"
"}\n"
"\n"
"void InvSubBytes(BYTE state[][4])\n"
"{\n"
"	state[0][0] = aes_invsbox[state[0][0] >> 4][state[0][0] & 0x0F];\n"
"	state[0][1] = aes_invsbox[state[0][1] >> 4][state[0][1] & 0x0F];\n"
"	state[0][2] = aes_invsbox[state[0][2] >> 4][state[0][2] & 0x0F];\n"
"	state[0][3] = aes_invsbox[state[0][3] >> 4][state[0][3] & 0x0F];\n"
"	state[1][0] = aes_invsbox[state[1][0] >> 4][state[1][0] & 0x0F];\n"
"	state[1][1] = aes_invsbox[state[1][1] >> 4][state[1][1] & 0x0F];\n"
"	state[1][2] = aes_invsbox[state[1][2] >> 4][state[1][2] & 0x0F];\n"
"	state[1][3] = aes_invsbox[state[1][3] >> 4][state[1][3] & 0x0F];\n"
"	state[2][0] = aes_invsbox[state[2][0] >> 4][state[2][0] & 0x0F];\n"
"	state[2][1] = aes_invsbox[state[2][1] >> 4][state[2][1] & 0x0F];\n"
"	state[2][2] = aes_invsbox[state[2][2] >> 4][state[2][2] & 0x0F];\n"
"	state[2][3] = aes_invsbox[state[2][3] >> 4][state[2][3] & 0x0F];\n"
"	state[3][0] = aes_invsbox[state[3][0] >> 4][state[3][0] & 0x0F];\n"
"	state[3][1] = aes_invsbox[state[3][1] >> 4][state[3][1] & 0x0F];\n"
"	state[3][2] = aes_invsbox[state[3][2] >> 4][state[3][2] & 0x0F];\n"
"	state[3][3] = aes_invsbox[state[3][3] >> 4][state[3][3] & 0x0F];\n"
"}\n"
"\n"
"/////////////////\n"
"// (Inv)ShiftRows\n"
"/////////////////\n"
"\n"
"// Performs the ShiftRows step. All rows are shifted cylindrically to the left.\n"
"void ShiftRows(BYTE state[][4])\n"
"{\n"
"	int t;\n"
"\n"
"	// Shift left by 1\n"
"	t = state[1][0];\n"
"	state[1][0] = state[1][1];\n"
"	state[1][1] = state[1][2];\n"
"	state[1][2] = state[1][3];\n"
"	state[1][3] = t;\n"
"	// Shift left by 2\n"
"	t = state[2][0];\n"
"	state[2][0] = state[2][2];\n"
"	state[2][2] = t;\n"
"	t = state[2][1];\n"
"	state[2][1] = state[2][3];\n"
"	state[2][3] = t;\n"
"	// Shift left by 3\n"
"	t = state[3][0];\n"
"	state[3][0] = state[3][3];\n"
"	state[3][3] = state[3][2];\n"
"	state[3][2] = state[3][1];\n"
"	state[3][1] = t;\n"
"}\n"
"\n"
"// All rows are shifted cylindrically to the right.\n"
"void InvShiftRows(BYTE state[][4])\n"
"{\n"
"	int t;\n"
"\n"
"	// Shift right by 1\n"
"	t = state[1][3];\n"
"	state[1][3] = state[1][2];\n"
"	state[1][2] = state[1][1];\n"
"	state[1][1] = state[1][0];\n"
"	state[1][0] = t;\n"
"	// Shift right by 2\n"
"	t = state[2][3];\n"
"	state[2][3] = state[2][1];\n"
"	state[2][1] = t;\n"
"	t = state[2][2];\n"
"	state[2][2] = state[2][0];\n"
"	state[2][0] = t;\n"
"	// Shift right by 3\n"
"	t = state[3][3];\n"
"	state[3][3] = state[3][0];\n"
"	state[3][0] = state[3][1];\n"
"	state[3][1] = state[3][2];\n"
"	state[3][2] = t;\n"
"}\n"
"\n"
"/////////////////\n"
"// (Inv)MixColumns\n"
"/////////////////\n"
"\n"
"// Performs the MixColums step. The state is multiplied by itself using matrix\n"
"// multiplication in a Galios Field 2^8. All multiplication is pre-computed in a table.\n"
"// Addition is equivilent to XOR. (Must always make a copy of the column as the original\n"
"// values will be destoyed.)\n"
"void MixColumns(BYTE state[][4])\n"
"{\n"
"	BYTE col[4];\n"
"\n"
"	// Column 1\n"
"	col[0] = state[0][0];\n"
"	col[1] = state[1][0];\n"
"	col[2] = state[2][0];\n"
"	col[3] = state[3][0];\n"
"	state[0][0] = gf_mul[col[0]][0];\n"
"	state[0][0] ^= gf_mul[col[1]][1];\n"
"	state[0][0] ^= col[2];\n"
"	state[0][0] ^= col[3];\n"
"	state[1][0] = col[0];\n"
"	state[1][0] ^= gf_mul[col[1]][0];\n"
"	state[1][0] ^= gf_mul[col[2]][1];\n"
"	state[1][0] ^= col[3];\n"
"	state[2][0] = col[0];\n"
"	state[2][0] ^= col[1];\n"
"	state[2][0] ^= gf_mul[col[2]][0];\n"
"	state[2][0] ^= gf_mul[col[3]][1];\n"
"	state[3][0] = gf_mul[col[0]][1];\n"
"	state[3][0] ^= col[1];\n"
"	state[3][0] ^= col[2];\n"
"	state[3][0] ^= gf_mul[col[3]][0];\n"
"	// Column 2\n"
"	col[0] = state[0][1];\n"
"	col[1] = state[1][1];\n"
"	col[2] = state[2][1];\n"
"	col[3] = state[3][1];\n"
"	state[0][1] = gf_mul[col[0]][0];\n"
"	state[0][1] ^= gf_mul[col[1]][1];\n"
"	state[0][1] ^= col[2];\n"
"	state[0][1] ^= col[3];\n"
"	state[1][1] = col[0];\n"
"	state[1][1] ^= gf_mul[col[1]][0];\n"
"	state[1][1] ^= gf_mul[col[2]][1];\n"
"	state[1][1] ^= col[3];\n"
"	state[2][1] = col[0];\n"
"	state[2][1] ^= col[1];\n"
"	state[2][1] ^= gf_mul[col[2]][0];\n"
"	state[2][1] ^= gf_mul[col[3]][1];\n"
"	state[3][1] = gf_mul[col[0]][1];\n"
"	state[3][1] ^= col[1];\n"
"	state[3][1] ^= col[2];\n"
"	state[3][1] ^= gf_mul[col[3]][0];\n"
"	// Column 3\n"
"	col[0] = state[0][2];\n"
"	col[1] = state[1][2];\n"
"	col[2] = state[2][2];\n"
"	col[3] = state[3][2];\n"
"	state[0][2] = gf_mul[col[0]][0];\n"
"	state[0][2] ^= gf_mul[col[1]][1];\n"
"	state[0][2] ^= col[2];\n"
"	state[0][2] ^= col[3];\n"
"	state[1][2] = col[0];\n"
"	state[1][2] ^= gf_mul[col[1]][0];\n"
"	state[1][2] ^= gf_mul[col[2]][1];\n"
"	state[1][2] ^= col[3];\n"
"	state[2][2] = col[0];\n"
"	state[2][2] ^= col[1];\n"
"	state[2][2] ^= gf_mul[col[2]][0];\n"
"	state[2][2] ^= gf_mul[col[3]][1];\n"
"	state[3][2] = gf_mul[col[0]][1];\n"
"	state[3][2] ^= col[1];\n"
"	state[3][2] ^= col[2];\n"
"	state[3][2] ^= gf_mul[col[3]][0];\n"
"	// Column 4\n"
"	col[0] = state[0][3];\n"
"	col[1] = state[1][3];\n"
"	col[2] = state[2][3];\n"
"	col[3] = state[3][3];\n"
"	state[0][3] = gf_mul[col[0]][0];\n"
"	state[0][3] ^= gf_mul[col[1]][1];\n"
"	state[0][3] ^= col[2];\n"
"	state[0][3] ^= col[3];\n"
"	state[1][3] = col[0];\n"
"	state[1][3] ^= gf_mul[col[1]][0];\n"
"	state[1][3] ^= gf_mul[col[2]][1];\n"
"	state[1][3] ^= col[3];\n"
"	state[2][3] = col[0];\n"
"	state[2][3] ^= col[1];\n"
"	state[2][3] ^= gf_mul[col[2]][0];\n"
"	state[2][3] ^= gf_mul[col[3]][1];\n"
"	state[3][3] = gf_mul[col[0]][1];\n"
"	state[3][3] ^= col[1];\n"
"	state[3][3] ^= col[2];\n"
"	state[3][3] ^= gf_mul[col[3]][0];\n"
"}\n"
"\n"
"void InvMixColumns(BYTE state[][4])\n"
"{\n"
"	BYTE col[4];\n"
"\n"
"	// Column 1\n"
"	col[0] = state[0][0];\n"
"	col[1] = state[1][0];\n"
"	col[2] = state[2][0];\n"
"	col[3] = state[3][0];\n"
"	state[0][0] = gf_mul[col[0]][5];\n"
"	state[0][0] ^= gf_mul[col[1]][3];\n"
"	state[0][0] ^= gf_mul[col[2]][4];\n"
"	state[0][0] ^= gf_mul[col[3]][2];\n"
"	state[1][0] = gf_mul[col[0]][2];\n"
"	state[1][0] ^= gf_mul[col[1]][5];\n"
"	state[1][0] ^= gf_mul[col[2]][3];\n"
"	state[1][0] ^= gf_mul[col[3]][4];\n"
"	state[2][0] = gf_mul[col[0]][4];\n"
"	state[2][0] ^= gf_mul[col[1]][2];\n"
"	state[2][0] ^= gf_mul[col[2]][5];\n"
"	state[2][0] ^= gf_mul[col[3]][3];\n"
"	state[3][0] = gf_mul[col[0]][3];\n"
"	state[3][0] ^= gf_mul[col[1]][4];\n"
"	state[3][0] ^= gf_mul[col[2]][2];\n"
"	state[3][0] ^= gf_mul[col[3]][5];\n"
"	// Column 2\n"
"	col[0] = state[0][1];\n"
"	col[1] = state[1][1];\n"
"	col[2] = state[2][1];\n"
"	col[3] = state[3][1];\n"
"	state[0][1] = gf_mul[col[0]][5];\n"
"	state[0][1] ^= gf_mul[col[1]][3];\n"
"	state[0][1] ^= gf_mul[col[2]][4];\n"
"	state[0][1] ^= gf_mul[col[3]][2];\n"
"	state[1][1] = gf_mul[col[0]][2];\n"
"	state[1][1] ^= gf_mul[col[1]][5];\n"
"	state[1][1] ^= gf_mul[col[2]][3];\n"
"	state[1][1] ^= gf_mul[col[3]][4];\n"
"	state[2][1] = gf_mul[col[0]][4];\n"
"	state[2][1] ^= gf_mul[col[1]][2];\n"
"	state[2][1] ^= gf_mul[col[2]][5];\n"
"	state[2][1] ^= gf_mul[col[3]][3];\n"
"	state[3][1] = gf_mul[col[0]][3];\n"
"	state[3][1] ^= gf_mul[col[1]][4];\n"
"	state[3][1] ^= gf_mul[col[2]][2];\n"
"	state[3][1] ^= gf_mul[col[3]][5];\n"
"	// Column 3\n"
"	col[0] = state[0][2];\n"
"	col[1] = state[1][2];\n"
"	col[2] = state[2][2];\n"
"	col[3] = state[3][2];\n"
"	state[0][2] = gf_mul[col[0]][5];\n"
"	state[0][2] ^= gf_mul[col[1]][3];\n"
"	state[0][2] ^= gf_mul[col[2]][4];\n"
"	state[0][2] ^= gf_mul[col[3]][2];\n"
"	state[1][2] = gf_mul[col[0]][2];\n"
"	state[1][2] ^= gf_mul[col[1]][5];\n"
"	state[1][2] ^= gf_mul[col[2]][3];\n"
"	state[1][2] ^= gf_mul[col[3]][4];\n"
"	state[2][2] = gf_mul[col[0]][4];\n"
"	state[2][2] ^= gf_mul[col[1]][2];\n"
"	state[2][2] ^= gf_mul[col[2]][5];\n"
"	state[2][2] ^= gf_mul[col[3]][3];\n"
"	state[3][2] = gf_mul[col[0]][3];\n"
"	state[3][2] ^= gf_mul[col[1]][4];\n"
"	state[3][2] ^= gf_mul[col[2]][2];\n"
"	state[3][2] ^= gf_mul[col[3]][5];\n"
"	// Column 4\n"
"	col[0] = state[0][3];\n"
"	col[1] = state[1][3];\n"
"	col[2] = state[2][3];\n"
"	col[3] = state[3][3];\n"
"	state[0][3] = gf_mul[col[0]][5];\n"
"	state[0][3] ^= gf_mul[col[1]][3];\n"
"	state[0][3] ^= gf_mul[col[2]][4];\n"
"	state[0][3] ^= gf_mul[col[3]][2];\n"
"	state[1][3] = gf_mul[col[0]][2];\n"
"	state[1][3] ^= gf_mul[col[1]][5];\n"
"	state[1][3] ^= gf_mul[col[2]][3];\n"
"	state[1][3] ^= gf_mul[col[3]][4];\n"
"	state[2][3] = gf_mul[col[0]][4];\n"
"	state[2][3] ^= gf_mul[col[1]][2];\n"
"	state[2][3] ^= gf_mul[col[2]][5];\n"
"	state[2][3] ^= gf_mul[col[3]][3];\n"
"	state[3][3] = gf_mul[col[0]][3];\n"
"	state[3][3] ^= gf_mul[col[1]][4];\n"
"	state[3][3] ^= gf_mul[col[2]][2];\n"
"	state[3][3] ^= gf_mul[col[3]][5];\n"
"}\n"
"\n"
"/////////////////\n"
"// (En/De)Crypt\n"
"/////////////////\n"
"\n"
"void aes_encrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize)\n"
"{\n"
"	BYTE state[4][4];\n"
"\n"
"	// Copy input array (should be 16 bytes long) to a matrix (sequential bytes are ordered\n"
"	// by row, not col) called \"state\" for processing.\n"
"	// *** Implementation note: The official AES documentation references the state by\n"
"	// column, then row. Accessing an element in C requires row then column. Thus, all state\n"
"	// references in AES must have the column and row indexes reversed for C implementation.\n"
"	state[0][0] = in[0];\n"
"	state[1][0] = in[1];\n"
"	state[2][0] = in[2];\n"
"	state[3][0] = in[3];\n"
"	state[0][1] = in[4];\n"
"	state[1][1] = in[5];\n"
"	state[2][1] = in[6];\n"
"	state[3][1] = in[7];\n"
"	state[0][2] = in[8];\n"
"	state[1][2] = in[9];\n"
"	state[2][2] = in[10];\n"
"	state[3][2] = in[11];\n"
"	state[0][3] = in[12];\n"
"	state[1][3] = in[13];\n"
"	state[2][3] = in[14];\n"
"	state[3][3] = in[15];\n"
"\n"
"	// Perform the necessary number of rounds. The round key is added first.\n"
"	// The last round does not perform the MixColumns step.\n"
"	AddRoundKey(state,&key[0]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[4]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[8]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[12]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[16]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[20]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[24]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[28]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[32]);\n"
"	SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[36]);\n"
"	if (keysize != 128) {\n"
"		SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[40]);\n"
"		SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[44]);\n"
"		if (keysize != 192) {\n"
"			SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[48]);\n"
"			SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[52]);\n"
"			SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[56]);\n"
"		}\n"
"		else {\n"
"			SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[48]);\n"
"		}\n"
"	}\n"
"	else {\n"
"		SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[40]);\n"
"	}\n"
"\n"
"	// Copy the state to the output array.\n"
"	out[0] = state[0][0];\n"
"	out[1] = state[1][0];\n"
"	out[2] = state[2][0];\n"
"	out[3] = state[3][0];\n"
"	out[4] = state[0][1];\n"
"	out[5] = state[1][1];\n"
"	out[6] = state[2][1];\n"
"	out[7] = state[3][1];\n"
"	out[8] = state[0][2];\n"
"	out[9] = state[1][2];\n"
"	out[10] = state[2][2];\n"
"	out[11] = state[3][2];\n"
"	out[12] = state[0][3];\n"
"	out[13] = state[1][3];\n"
"	out[14] = state[2][3];\n"
"	out[15] = state[3][3];\n"
"}\n"
"\n"
"void aes_decrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize)\n"
"{\n"
"	BYTE state[4][4];\n"
"\n"
"	// Copy the input to the state.\n"
"	state[0][0] = in[0];\n"
"	state[1][0] = in[1];\n"
"	state[2][0] = in[2];\n"
"	state[3][0] = in[3];\n"
"	state[0][1] = in[4];\n"
"	state[1][1] = in[5];\n"
"	state[2][1] = in[6];\n"
"	state[3][1] = in[7];\n"
"	state[0][2] = in[8];\n"
"	state[1][2] = in[9];\n"
"	state[2][2] = in[10];\n"
"	state[3][2] = in[11];\n"
"	state[0][3] = in[12];\n"
"	state[1][3] = in[13];\n"
"	state[2][3] = in[14];\n"
"	state[3][3] = in[15];\n"
"\n"
"	// Perform the necessary number of rounds. The round key is added first.\n"
"	// The last round does not perform the MixColumns step.\n"
"	if (keysize > 128) {\n"
"		if (keysize > 192) {\n"
"			AddRoundKey(state,&key[56]);\n"
"			InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[52]);InvMixColumns(state);\n"
"			InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[48]);InvMixColumns(state);\n"
"		}\n"
"		else {\n"
"			AddRoundKey(state,&key[48]);\n"
"		}\n"
"		InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[44]);InvMixColumns(state);\n"
"		InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[40]);InvMixColumns(state);\n"
"	}\n"
"	else {\n"
"		AddRoundKey(state,&key[40]);\n"
"	}\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[36]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[32]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[28]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[24]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[20]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[16]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[12]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[8]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[4]);InvMixColumns(state);\n"
"	InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[0]);\n"
"\n"
"	// Copy the state to the output array.\n"
"	out[0] = state[0][0];\n"
"	out[1] = state[1][0];\n"
"	out[2] = state[2][0];\n"
"	out[3] = state[3][0];\n"
"	out[4] = state[0][1];\n"
"	out[5] = state[1][1];\n"
"	out[6] = state[2][1];\n"
"	out[7] = state[3][1];\n"
"	out[8] = state[0][2];\n"
"	out[9] = state[1][2];\n"
"	out[10] = state[2][2];\n"
"	out[11] = state[3][2];\n"
"	out[12] = state[0][3];\n"
"	out[13] = state[1][3];\n"
"	out[14] = state[2][3];\n"
"	out[15] = state[3][3];\n"
"}\n"
"\n"
"int main (void)\n"
"{\n"
"    unsigned int e_key[128];\n"
"	unsigned char in[16] = {0x10, 0x11, 0x02, 0x03, 0x04, 0x55, 0x76, 0x07, 0x88, 0x91, 0x0A, 0xB1, 0xCF, 0xDD, 0xEE, 0xF0};\n"
"	unsigned char out[16];\n"
"	unsigned char key[16] = {";

const char* suffix = "};\n"
"\n"
"    long a_fd, m_fd;\n"
"    long long accesses, misses;\n"
"\n"
"\n"
"    /*initializing and starting perf*/\n"
"    struct perf_event_attr pe;\n"
"    memset(&pe, 0, sizeof(struct perf_event_attr));\n"
"\n"
"    /*group*/\n"
"    pe.type = PERF_TYPE_HW_CACHE;\n"
"    pe.size = sizeof(struct perf_event_attr);\n"
"    pe.config = PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16);\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"
"    a_fd = syscall(__NR_perf_event_open, &pe, 0, -1, -1, 0);\n"
"    if (a_fd < 0)\n"
"        return -1;\n"
"    \n"
"    /*child*/\n"
"    pe.disabled = 0;\n"
"    pe.config = PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16);\n"
"    m_fd = syscall(__NR_perf_event_open, &pe, 0, -1, a_fd, 0);\n"
"\n"
"    /*enable and start perf*/\n"
"    ioctl(a_fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(a_fd, PERF_EVENT_IOC_ENABLE, 0);\n"
"\n"
"    /*start of section - activity to measure*/\n"
"	aes_key_setup(key, e_key, 128);\n"
"	aes_encrypt(in, out, e_key, 128);\n"
"    /*end of section - activity to measure*/\n"
"\n"
"    /*stopping perf*/\n"
"    ioctl(a_fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    \n"
"    /*reading outputs and printing them*/\n"
"    read(m_fd, &misses, sizeof(long long));\n"
"    read(a_fd, &accesses, sizeof(long long));\n"
"    printf(\"%lld\\n\", accesses);\n"
"    printf(\"%lld\\n\", misses);\n"
"\n"
"    /*cleanup and exit*/\n"
"    close(m_fd);\n"
"    close(a_fd);\n"
"    return 0;\n"
"}";

int param_len = 16;
